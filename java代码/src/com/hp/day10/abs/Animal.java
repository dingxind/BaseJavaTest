package com.hp.day10.abs;

/**
 * 抽象类：
 * 1、用abstract修饰
 * 2、抽象类可以有抽象方法，也可以没有；有抽象方法的类一定是抽象类
 * 3、抽象类不能被实例化，不能用构造方法创建对象
 * 4、应用场景：a.类不想被实例化，想通过子类实现
 * 			b.在父类中，方法实现无法覆盖子类的要求
 * 5、如果子类没有实现父类的抽象方法，子类必须是抽象类
 * 抽象方法：
 * 父类中定义了方法的返回值，方法名，参数列表，子类必须遵守
 * @author HP
 */
public abstract class Animal {
	/**
	 * 不同的小动物，吃的行为不同，无法有统一的实现
	 * 所以，方法声明为抽象方法
	 * 方法的声明：声明没有方法体
	 * public abstract void eat()
	 * 方法的定义：[]表示可有可无
	 * [修饰符] 返回类型 方法名([参数列表])
	 * public void eat() {
	 * }
	 */
	public abstract void eat();
	
	public static void main(String [] args){
		/**
		 * 不能实例化一个抽象类：
		 * 原因：假设可以，有了对象后，可以通过对象调用方法
		 * 抽象类中可能有抽象方法，抽象方法没有实现，只有声明
		 * 所以没法调用方法
		 */
//		Animal animal = new Animal();
		/**
		 * abstract不能修饰属性（成员变量）：
		 * 		系统会赋默认初始化值，abstract修饰的只能是抽象的不能是具体的；从语法上也不能修饰
		 * abstract不能修饰私有方法：
		 * 		私有方法只能本类访问，abstract修饰的只有方法的声明，没有定义，需要在子类中实现，但是子类没有权限访问
		 * abstract不能修饰构造方法：
		 * 		假设能修饰，子类需要实现父类的构造方法；构造方法只能和本类类名相同；所以不能修饰
		 * abstract不能修饰静态方法：
		 * 		静态方法通过类名.方法名调用Math.pow；如果可以，但是方法没有具体实现，矛盾，所以不能修饰
		 * abstract不能修饰final方法：
		 * 		final修饰的方法不能被重写，abstract修饰的方法一般要求重写的，矛盾
		 */
	}
}
